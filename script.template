#!/usr/bin/env bash

# Unison Sync with Power Nap Protection
#
# Lock screen detection - pauses sync when screen locked, resumes when unlocked
# Watch mode monitoring - detects failures, runs backup sync, restarts automatically  
# Custom unison binary - uses .~unison.temp files (Dropbox ignores .~ prefix)
# Session logging - tracks start/stop events with timestamps in ~/.unison/session.log
# Signal handling - graceful shutdown, manual restart with kill -USR1 <pid>
#
# Power Nap protection: Lock your screen before walking away. Sync stops within 30 seconds
# and stays stopped during Power Nap. Unlocking resumes sync automatically.

# How this works:
# 1. Main loop runs every 30 seconds, calls should_continue_sync()
# 2. should_continue_sync() uses ioreg to check CGSSessionScreenIsLocked
# 3. Direct process checking with pgrep/pkill for simple lifecycle management
# 4. All state changes logged with timestamps to session.log
# 5. Immediately detects and restarts dead processes (no 5-minute delay)
# 6. Signal handling for cleanup on TERM/INT/EXIT, manual restart on USR1

# Session log file for startup/shutdown tracking
SESSION_LOG="{{BASE_PATH}}/session.log"

# Logging function with timestamps
log_session() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$SESSION_LOG"
}

# Security check: Ensure script is run by the same user who installed it
INSTALLED_USER="{{INSTALLED_USER}}"
if [[ "$USER" != "$INSTALLED_USER" ]]; then
    log_session "ERROR: Sync script installed by '$INSTALLED_USER' but run by '$USER'"
    exit 1
fi

# Check if screen is locked - called every 30 seconds
# Uses ioreg to check CGSSessionScreenIsLocked in macOS I/O Kit registry
# Returns "true" when locked (Cmd+Ctrl+Q), "false" when unlocked
# Works during normal use, Power Nap, and sleep/wake cycles
should_continue_sync() {
    # Query macOS for current screen lock state
    lock_status=$(/usr/libexec/PlistBuddy -c "print :IOConsoleUsers:0:CGSSessionScreenIsLocked" /dev/stdin 2>/dev/null <<< "$(ioreg -n Root -d1 -a)" 2>/dev/null)
    if [[ "$lock_status" == "true" ]]; then
        return 1  # Screen locked - stop sync
    fi
    
    return 0  # Screen unlocked - allow sync
}

# Add visual separator for new session
echo "" >> "$SESSION_LOG"
log_session "=== NEW SESSION STARTED ==="
log_session "STARTUP: Sync script started"

# Unison command variables - using arrays to avoid eval issues
UNISON_COMMON_ARGS=({{UNISON_FLAGS}} -logfile={{LOG_FILE}} -ignore="Name {{{IGNORE_FILES}}}" "{{LOCAL_PATH}}" "{{CLOUD_PATH}}")
UNISON_BASE_CMD=("{{UNISON_PATH}}" "${UNISON_COMMON_ARGS[@]}")
UNISON_WATCH_CMD=("{{UNISON_PATH}}" -repeat=watch "${UNISON_COMMON_ARGS[@]}")

# Simple monitoring loop - runs every 30 seconds  
last_sync_state=""
sync_was_running=false

while true; do
    if should_continue_sync; then
        # Screen unlocked - sync should be running
        if [[ "$last_sync_state" != "running" ]]; then
            log_session "Conditions good - sync allowed"
            last_sync_state="running"
        fi
        
        # Check if sync process is actually running
        if ! pgrep -f "{{UNISON_PATH}}.*-repeat=watch" >/dev/null; then
            if [[ "$sync_was_running" == "true" ]]; then
                log_session "ALERT: Watch mode died - restarting immediately"
            else
                log_session "SYNC STARTED: Starting watch mode"
            fi
            
            # Run full sync first, then start watch mode
            "${UNISON_BASE_CMD[@]}"
            sleep 1
            "${UNISON_WATCH_CMD[@]}" &
            sync_was_running=true
        fi
    else
        # Screen locked - pause sync immediately
        if [[ "$last_sync_state" != "paused" ]]; then
            log_session "Conditions not met - sync paused (screen locked)"
            last_sync_state="paused"
        fi
        
        if pgrep -f "{{UNISON_PATH}}.*-repeat=watch" >/dev/null; then
            log_session "SYNC STOPPED: Stopping watch mode"
            pkill -f "{{UNISON_PATH}}.*-repeat=watch"
            sync_was_running=false
        fi
    fi
    
    sleep 30
done

# Cleanup function
cleanup() {
    log_session "SHUTDOWN: Sync stopping (cleanup called)"
    pkill -f "{{UNISON_PATH}}.*-repeat=watch" 2>/dev/null || true
    exit 0
}

# Signal handling for graceful shutdown
trap cleanup TERM INT QUIT HUP
trap 'log_session "Received SIGUSR1 - forcing sync restart"; pkill -f "{{UNISON_PATH}}.*-repeat=watch" 2>/dev/null || true; sync_was_running=false' USR1

# Set up EXIT trap separately to avoid double cleanup
trap 'cleanup' EXIT
